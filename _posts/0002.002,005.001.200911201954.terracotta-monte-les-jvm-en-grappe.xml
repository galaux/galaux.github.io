<?xml version='1.0' encoding='UTF-8'?>
<document>
	<title><![CDATA[Terracotta monte les JVM en grappe]]></title>
	<allow_com>0</allow_com>
	<template><![CDATA[article.php]]></template>
	<chapo><![CDATA[]]></chapo>
	<content><![CDATA[<p><img class="alignright size-full wp-image-1545" src="http://08000linux.com/blogs/files/2009/11/logo.png" alt="logo" width="220" height="27" />Pour satisfaire les besoins des applications JavaEE modernes, le recours au <em>clustering</em> est souvent indispensable. Celui-ci vise à augmenter les ressources allouées aux applications en multipliant les serveurs à sa disposition. Les solutions de <em>clustering</em> de serveurs d'application et de bases de données sont légions dans les environnements techniques des entreprises modernes mais qu'en est-il du clustering de JVM?</p>

<p>C'est la mission que s'est donnée <a href="http://www.terracotta.org/">Terracotta</a> avec son outil OpenTerracotta. L'idée derrière le concept de Terracotta est de <em>descendre</em> la mise en grappe d'un cran pour l'appliquer directement aux machines virtuelles Java. Ceci permet de faire fonctionner une application trop gourmande pour une seule JVM sur plusieurs d'entre-elles de façon complètement transparente pour l'applicatif. De cette manière, le développeur est débarrassé de toute préoccupation de programmation en grappe et peut ainsi se consacrer pleinement à son application dont la conception est de fait simplifiée.<br />
L'architecture d'une telle solution est classique quand il s'agit de <em>clustering</em> : un serveur, des clients et (moins courant) un serveur de stockage.</p>

<a href="http://08000linux.com/blogs/files/2009/11/terracotta_architecture.png"><img class="aligncenter size-full wp-image-1544" src="http://08000linux.com/blogs/files/2009/11/terracotta_architecture.png" alt="terracotta_architecture" width="100%" /></a>

<p>Les clients accueillent chacun une JVM qui inclut au démarrage un ensemble d'API Terracotta. Leur rôle est d'intercepter les appels Java responsables de la synchronisation des processus est d'y injecter du <em>bytecode</em> afin d'informer le serveur Terracotta des changements effectués sur le tas (<em>heap</em>) et donc les altérations subies par les objets. Les composants Terracotta répartis ne s'échangent que des deltas sur les objets des tas et économise ainsi la bande passante. Toutes les données qui concernent les objets Java sont enfin conservées par le serveur de stockage.
Dans les faits, Terracotta trouve quatre champs d'applications majeurs :
<ul>
	<li>Réplication de sessions HTTP (Tomcat, Oracle WebLogic, Struts, Spring, ...)</li>
	<li>Cache Distribué</li>
	<li><em>Clustering</em> de POJO/Intégration Spring</li>
	<li>Collaboration, Coordination, et gestion d'évènements</li>
</ul>
Pour une présentation plus détaillée de cet outil ambitieux qu'est Terracotta, se référer à <a href="http://blog.zenika.com/index.php?post/2009/05/05/Présentation-de-Terracotta2">cet autre article</a> du blog Zenika.com. On ne pourra ensuite que citer les très bons et très techniques articles en anglais <a href="http://www.infoq.com/articles/open-terracotta-intro">d'infoq.com</a> et de <a href="http://www.javaworld.com/javaworld/jw-01-2009/jw-01-osjp-terracotta.html">javaworld.com</a> pour dévoiler les derniers secrets de l'outil.</p>

<p><em>Article publié sur <a href="http://linuxfr.org/~galaux">LinuxFr</a> dans le cadre de mon activité professionnelle à <a href="http://linagora.com/">Linagora</a>.</em></p>]]></content>
	<tags><![CDATA[java,administration]]></tags>
</document>