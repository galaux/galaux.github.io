<?xml version='1.0' encoding='UTF-8'?>
<document>
	<title><![CDATA[Revue d'architecture pour GWT]]></title>
	<allow_com>1</allow_com>
	<template><![CDATA[article.php]]></template>
	<chapo><![CDATA[]]></chapo>
	<content><![CDATA[<p><em>This article in french belongs to a serie of articles I intend to write about a web application I am currently developping for training purpose. The english version of the articles should come up later. In the meantime you can still have a look at <a href="https://github.com/galaux/diosmio">the source code of the application</a>.</em></p>

<p><a href="https://developers.google.com/web-toolkit/">GWT</a> est un ensemble de composants graphiques pour application web mais qui veut s'y initier s'aperçoit vite que le vrai challenge ne se situe pas dans les composants eux-même mais dans l'architecture de l'application qui utilise ces composants. À la lecture des <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuide">tutoriels officiel de Google</a>, on découvre qu'il existe une multitude de <em>patterns</em>, de méthodes et de frameworks pour architecturer une application GWT. Certains sont officiels Google, d'autres non, certains sont compatibles entre eux, certains plus adapté à certains cas d'utilisation.</p>

<p>De plus, beaucoup d'articles quoique très utiles à titre d'exemple proposent des implémentations très minimalistes. Il est rare de voir détaillée une application GWT complète de la couche de persistance à la couche présentation.</p>

<p>Cet article a pour but de survoler à haut niveau ces frameworks afin d'orienter lors d'une initiation à GWT. Le but n'est sûrement pas d'expliquer comment les mettre en oeuvre ; cela ne servirait à rien : internet regorge d'exemples. Enfin un autre article sera consacré à quelques points spécifiques à la mise en place d'un ensemble de ces solutions.</p>

<h3>Model View Presenter (MVP)</h3>
<p><a href="https://developers.google.com/web-toolkit/articles/mvp-architecture">MVP</a> est le design pattern poussé par Google comme ossature générale d'une application GWT. Il est relativement similaire au <a href="http://fr.wikipedia.org/wiki/Mod%C3%A8le-Vue-Contr%C3%B4leur">pattern Model View Controller (MVC)</a> : les <tt>Views</tt> déclarent les composants GWT, leurs positionnements, certaines configurations de style, de visibilité puis sont vite rattachées à leur <tt>Presenter</tt> respectif. Celui-ci reçoit les événements des <tt>Views</tt> et les traite en appelant au besoin une couche de service de façon asynchrone. Une fois reçus, le résultat des requêtes serveur est traité par les <tt>Presenters</tt> et affiché dans les <tt>Views</tt>. La déclaration de tous ces éléments est dévolue à un <tt>Controller</tt> qui porte aussi un <tt>EventBus</tt> pour faciliter la communication entre <tt>Presenters</tt>.</p>
<p>La meilleure manière de débuter avec GWT et MVP est de dérouler <a href="https://developers.google.com/web-toolkit/articles/mvp-architecture">le tutoriel de Google en 2 parties</a>. À noter : le framework non-officiel <a href="http://code.google.com/p/gwt-platform/">gwt-platform</a> permet de faciliter la mise en place de MVP.</p>

<h3>UIBinder</h3>
<p>La deuxième partie du <a href="https://developers.google.com/web-toolkit/articles/mvp-architecture">tutoriel de Google</a> cité précédemment propose l'utilisation de <a href="https://developers.google.com/web-toolkit/articles/mvp-architecture-2">UIBinder</a>. Ce framework permet de déclarer tous les composants des <tt>Views</tt> et leurs configuration initiale dans des fichiers XML et allège donc considérablement leur code. Il permet enfin de disposer d'un éditeur <a href="http://fr.wikipedia.org/wiki/What_you_see_is_what_you_get">WYSIWYG</a> sous Eclipse. UIBinder est à mon sens un minimum vital pour un projet efficace.</p>

<h3>Appels asynchrones au serveur via XML-RPC</h3>
<p>Toujours dans son <a href="https://developers.google.com/web-toolkit/articles/mvp-architecture">tutoriel en 2 étapes</a>, Google met en place une communication client (navigateur)/serveur (webapp) basé sur des appels asynchrones XML-RPC. C'est le système standard qui conviendra à beaucoup d'applications mais qui peut induire des complications lors de l'utilisation de couches de persistance comme <a href="http://fr.wikipedia.org/wiki/Java_Persistence_API">JPA</a>. La norme JPA préconise en effet d'améliorer (<em>enhance</em>) le code des entités ce qui les rendra <em>incompréhensibles</em> par GWT. En effet pour passer les entités entre le client et le serveur, GWT a besoin de <em>parser</em> le code entités afin de les rendre sérialisables. Or ce code source initial des entités que GWT <em>parse</em> ne correspond plus au bytecode généré par la compilation puisqu'entre temps JPA est passé par là pour <em>améliorer</em> celles-ci. Un article traitera de la mise en place de JPA dans une application GWT dans lequel on verra que la seule solution avec cette technique est de créer des DTO pour GWT.</p>

<h3>Editor</h3>
<p>Le <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideUiEditors">framework Editor</a> peut être utilisé avec n'importe quel autre framework cité précédemment. Il permet de créer un lien automatique entre les objets traités par la partie serveur (<a href="http://fr.wikipedia.org/wiki/Plain_Old_Java_Object">POJO</a> <tt>Artifact</tt> par exemple) et les <tt>Views</tt> qui affichent et modifient des instances héritées de <tt>Editor</tt> (<tt>ArtifactEditor</tt>). Un objet hérité de <tt>Driver</tt> fait ensuite le lien entre l'entité et son <tt>Editor</tt>.
Le développeur peut ensuite appeler la méthode <tt>driver.edit(artifactEditor)</tt> pour spécifier que les données ont été modifiées dans la vue (charge au développeur de traiter ces changement comme par exemple les répercuter dans le modèle). Attention cependant les vues et leurs éditeurs peuvent devenir plus compliqués à implémenter s'il faut <em>mapper</em> un modèle dont les données sont elles-mêmes imbriquées.</p>

<h3>Activity and Place</h3>
<p>Comme les composants GWT s'affichent dans un navigateur, l'utilisateur peut être tenté d'utiliser le bouton <em>Précédent</em> pour revenir intuitivement à un écran précédent. Cela pose généralement des problèmes aux applications web qui doivent maintenir des informations en session. Le framework <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideMvpActivitiesAndPlaces">Activity and Places</a> propose la gestion de cet historique dans l'application. Notons que <a href="https://developers.google.com/web-toolkit/articles/mvp-architecture-2">le tutoriel de Google sur MVP de Google</a> propose déjà une gestion simple de l'historique via la classe <tt>EventBus</tt>.</p>

<h3>RequestFactory</h3>
<p>Le framework <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideRequestFactory">RequestFactory</a> proposé par Google remplace dans son emploi les appels XML-RPC entre le client et le serveur. Il permet une réduction du volume d'échanges client/serveur ainsi qu'une proximité plus grande avec la couche de persistance via la déclaration pour chaque entitée (<tt>Artifact</tt> par exemple) d'un <tt>Proxy</tt> correspondant (<tt>ArtifactProxy</tt>). Ce <tt>Proxy</tt> est une version légère de l'entité qui sera utilisable dans la partie cliente de GWT. Le framework RequestFactory se charge de maintenir à jour le <tt>Proxy</tt> avec les éléments de la vue. Là encore, il est possible depuis le client d'appeler le serveur de manière asynchrone.</p>
<p>Cette solution apporte une solution simple au problème de <em>enhancement</em> décrit plus haut grâce aux <tt>Proxies</tt> qui sont en quelque sorte des <a href="http://fr.wikipedia.org/wiki/Objet_de_transfert_de_donn%C3%A9es">DTO</a> mais dont la gestion est dévolue au framework RequestFactory et non plus au développeur. <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideRequestFactory#locators">Le tutoriel proposé par Google</a> pousse le concept plus loin en proposant d'utiliser des <tt>Locator</tt>s et <tt>ServiceLocator</tt>s pour lier automatiquement la partie serveur de GWT au DAO de l'application et même de <em>détecter</em> et d'utiliser automatiquement ses méthodes standards du type <tt>find()</tt>, <tt>persist()</tt>, <tt>delete()</tt>, etc.</p>
<p>Cette solution semble particulièrement adaptée pour des applications à faible contenu métier, des applications <a href="http://fr.wikipedia.org/wiki/CRUD">CRUD</a>. On peut cependant imaginer utiliser un mélange des deux solutions : RequestFactory pour les parties de l'application qui ne font que créer, supprimer mettre à jour des entités et des DTO pour les parties au métier plus complexe.</p>

<p>L'application complète de test <a href="http://www.alaux.net/index.php?article34/dios-mio-ecorche-d-une-webapp-fr">Dios Mio</a> dont vous pouvez retrouver <a href="https://github.com/galaux/diosmio">le code source sur Github</a> met en pratique certains de ces frameworks. Enfin, un prochain article exposera l'intégration de beans <a href="http://www.springsource.org/">Springs</a> dans Dios Mio.</p>]]></content>
	<tags><![CDATA[java,development]]></tags>
	<meta_description><![CDATA[]]></meta_description>
	<meta_keywords><![CDATA[]]></meta_keywords>
	<title_htmltag><![CDATA[]]></title_htmltag>
</document>
